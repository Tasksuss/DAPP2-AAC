import tkinter as tk
import time
import threading
from typing import List, Dict, Tuple, Any
import pygame
from gtts import gTTS
import os
import math
import re


class AAC_GUI():
    """
    This is the main OOP program for creating the interactive GUI.
    Revised version that accepts terminal commands instead of hover selection.
    Commands:
    - 1, 2, 3, 4: Select main sections (top, right, bottom, left)
    - 5, 6, 7, 8: Corner controls (mode switch, return, delete, confirm)
    - 1a, 1b, etc: Select specific letters in secondary panels
    """

    RIGHT: list[str] = ['a', 'e', 'i', 'o', 'u']

    TOP: list[str] = ["s", "t", "n", "r", "d", "l", "h"]

    LEFT: list[str] = ["c", "w", "m", "g", "y", "p", "f"]

    BOTTOM: list[str] = ["j", "b", "q", "k", "v", "z", "x"]

    # Base color #3388ff with different opacity levels
    COLORS: Dict[str, str] = {
        "background": "black",
        "border": "white",
        "text": "white",
        "highlight_0": "black",  # No highlight
        "highlight_1": "#3388ff33",  # 20% opacity
        "highlight_2": "#3388ff66",  # 40% opacity
        "highlight_3": "#3388ff99",  # 60% opacity
        "highlight_4": "#3388ffcc",  # 80% opacity
        "ring": "black",
        "confirm": "white",
        "cancel": "white",
        "side": "black"
    }

    # Fallback colors for systems that don't support alpha channels in hex
    FALLBACK_COLORS: Dict[str, str] = {
        "highlight_0": "black",
        "highlight_1": "#cceeff",  # Very light blue
        "highlight_2": "#99ccff",  # Light blue
        "highlight_3": "#66aaff",  # Medium blue
        "highlight_4": "#3388ff",  # Full blue
    }

    FONT: Dict[str, int] = {
        'small': 8,
        'middle': 12,
        'large': 16
    }

    STATES: list[str] = ['MAIN', 'RIGHT', 'TOP', 'LEFT', 'BOTTOM', 'NUM']

    def __init__(self, root: tk.Tk) -> None:
        self.root = root
        self.state = 'MAIN'  # Current panel shown on the screen
        self.current_text = ''
        self.volume = 100  # from 0 to 100

        # Main section selection counters
        self.selection_counters = {
            "TOP": 0,
            "RIGHT": 0,
            "BOTTOM": 0,
            "LEFT": 0
        }

        # Secondary selection counters (for each letter in each section)
        self.secondary_counters = {
            "TOP": [0] * len(self.TOP),
            "RIGHT": [0] * len(self.RIGHT),
            "BOTTOM": [0] * len(self.BOTTOM),
            "LEFT": [0] * len(self.LEFT)
        }

        # Current active secondary section (if any)
        self.active_secondary = None
        self.active_secondary_index = -1

        # Test for alpha channel support in tkinter
        try:
            self.root.winfo_rgb("#3388ff33")
            self.supports_alpha = True
        except:
            self.supports_alpha = False
            print("Warning: System doesn't support alpha channels in colors. Using fallback colors.")

        self.root.title("AAC Keyboard - Command Based")
        self.canvas = tk.Canvas(self.root, width=500, height=500, bg=self.COLORS["background"])
        self.canvas.pack()

        self.letters = {
            "RIGHT": self.RIGHT,
            "TOP": self.TOP,
            "LEFT": self.LEFT,
            "BOTTOM": self.BOTTOM
        }

        self.numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '.']
        self.character_positions = {}
        self.section_ids = {}  # Store canvas IDs for main sections
        self.secondary_section_ids = {}  # Store canvas IDs for secondary sections

        self.compute_character_positions()
        self.setup_UI()

        # Start command input thread
        self.command_thread = threading.Thread(target=self.command_listener, daemon=True)
        self.command_thread.start()

    def get_color(self, color_key: str) -> str:
        """Get the appropriate color based on alpha channel support"""
        if not self.supports_alpha and color_key.startswith("highlight_"):
            return self.FALLBACK_COLORS[color_key]
        return self.COLORS[color_key]

    def compute_character_positions(self) -> None:
        """
        Precomputes positions for all characters and buttons.
        - MAIN mode: Clusters letters within 45-degree sectors.
        - Secondary mode: Letters distributed in equal segments around the full circle.
        - Special buttons (NUM, ⟲, ✔, X) use Cartesian coordinates.
        """
        center_x, center_y = 250, 250  # Center of the screen
        ring_radius = 100  # Distance from center for MAIN view

        ### --- MAIN VIEW: Cluster Letters in 45-degree Sectors --- ###
        sector_angles = {
            "RIGHT": (-22.5, 22.5),
            "TOP": (60, 120),
            "LEFT": (150, 210),
            "BOTTOM": (240, 300),
        }

        # Cluster letters inside 45-degree sectors
        for quadrant, chars in zip(sector_angles.keys(), [self.RIGHT, self.TOP, self.LEFT, self.BOTTOM]):
            start_angle, end_angle = sector_angles[quadrant]
            angle_step = (end_angle - start_angle) / len(chars)
            for i, char in enumerate(chars):
                angle = math.radians(start_angle + i * angle_step)
                self.character_positions[(char, "MAIN")] = (
                    center_x + ring_radius * math.cos(angle),
                    center_y - ring_radius * math.sin(angle)
                )

        ### --- SECONDARY VIEW: Full circle with equal segments --- ###
        for section, chars in self.letters.items():
            num_chars = len(chars)
            for i, char in enumerate(chars):
                # Calculate angle for arc segments - divide 360 degrees evenly
                start_angle = 360 * i / num_chars
                end_angle = 360 * (i + 1) / num_chars

                # Store the start and end angles for drawing arcs
                self.character_positions[(f"{char}_start", section)] = start_angle
                self.character_positions[(f"{char}_end", section)] = end_angle

                # Calculate angle for text position - in the middle of the segment
                text_angle = math.radians((start_angle + end_angle) / 2)

                # Store position for text - place it at 90% of the radius (moved 20% outward from 75%)
                self.character_positions[(char, section)] = (
                    center_x + (ring_radius * 0.9) * math.cos(text_angle),
                    center_y - (ring_radius * 0.9) * math.sin(text_angle)
                )

        ### --- NUMBERS: 11 Equally Spaced Positions in a Circle --- ###
        for i, num in enumerate(self.numbers):
            # Calculate angle for arc segments
            start_angle = 360 * i / len(self.numbers)
            end_angle = 360 * (i + 1) / len(self.numbers)

            # Store the start and end angles for drawing arcs
            self.character_positions[(f"{num}_start", "NUM")] = start_angle
            self.character_positions[(f"{num}_end", "NUM")] = end_angle

            # Calculate angle for text position - in the middle of the segment
            text_angle = math.radians((start_angle + end_angle) / 2)

            # Store position for text - place it at 90% of the radius (moved 20% outward from 75%)
            self.character_positions[(num, "NUM")] = (
                center_x + (ring_radius * 0.9) * math.cos(text_angle),
                center_y - (ring_radius * 0.9) * math.sin(text_angle)
            )

        ### --- SPECIAL BUTTONS (NUM, ⟲, ✔, X) --- ###
        button_positions = {
            "NUM": (100, 100),  # Top-left
            "⟲": (400, 100),  # Top-right
            "✔": (400, 400),  # Bottom-right
            "X": (100, 400)  # Bottom-left
        }

        for button, pos in button_positions.items():
            self.character_positions[(button, "BUTTON")] = pos

    def setup_UI(self):
        """
        The four side buttons are at the lowest layer.
        On top of it is the ring, but it is in fact also a circle.
        On the topmost is the central circle for the text display.
        """
        self.create_side()
        self.create_ring()
        self.create_circle()

    def create_side(self):
        """Creates the four side buttons with explicitly defined positions and colors."""
        # Define explicit positions for each button
        num_x, num_y = self.character_positions[("NUM", "BUTTON")]
        return_x, return_y = self.character_positions[("⟲", "BUTTON")]
        confirm_x, confirm_y = self.character_positions[("✔", "BUTTON")]
        cancel_x, cancel_y = self.character_positions[("X", "BUTTON")]

        # Draw NUM button (5)
        self.canvas.create_rectangle(num_x - 150, num_y - 150, num_x + 150, num_y + 150,
                                     outline=self.COLORS["border"], fill=self.COLORS["side"], width=3,
                                     tags="side_button")
        self.canvas.create_text(num_x, num_y, text="NUM", fill=self.COLORS["text"],
                                font=("Arial", self.FONT["middle"]), tags="side_button")

        # Draw Return button (6)
        self.canvas.create_rectangle(return_x - 150, return_y - 150, return_x + 150, return_y + 150,
                                     outline=self.COLORS["border"], fill=self.COLORS["side"], width=3,
                                     tags="side_button")
        self.canvas.create_text(return_x, return_y, text="⟲", fill=self.COLORS["text"],
                                font=("Arial", self.FONT["middle"]), tags="side_button")

        # Draw Confirm button (8)
        self.canvas.create_rectangle(confirm_x - 150, confirm_y - 150, confirm_x + 150, confirm_y + 150,
                                     outline=self.COLORS["border"], fill=self.COLORS["side"], width=3,
                                     tags="side_button")
        self.canvas.create_text(confirm_x, confirm_y, text="✔", fill=self.COLORS["confirm"],
                                font=("Arial", self.FONT["middle"]), tags="side_button")

        # Draw Cancel/Delete button (7)
        self.canvas.create_rectangle(cancel_x - 150, cancel_y - 150, cancel_x + 150, cancel_y + 150,
                                     outline=self.COLORS["border"], fill=self.COLORS["side"], width=3,
                                     tags="side_button")
        self.canvas.create_text(cancel_x, cancel_y, text="X", fill=self.COLORS["cancel"],
                                font=("Arial", self.FONT["middle"]), tags="side_button")

    def create_ring(self):
        """Draws the four-sectioned ring with arcs."""
        # Create the outer ring
        self.canvas.create_oval(100, 100, 400, 400, outline=self.COLORS["border"],
                                fill=self.COLORS["background"], width=3, tags="outer_ring")

        # Create the four sections with their command numbers and store their IDs
        self.section_ids["TOP"] = self.canvas.create_arc(100, 100, 400, 400, start=45, extent=90,
                                                         outline=self.COLORS["border"],
                                                         fill=self.COLORS["ring"], width=3, tags="TOP")

        self.section_ids["RIGHT"] = self.canvas.create_arc(100, 100, 400, 400, start=315, extent=90,
                                                           outline=self.COLORS["border"],
                                                           fill=self.COLORS["ring"], width=3, tags="RIGHT")

        self.section_ids["BOTTOM"] = self.canvas.create_arc(100, 100, 400, 400, start=225, extent=90,
                                                            outline=self.COLORS["border"],
                                                            fill=self.COLORS["ring"], width=3, tags="BOTTOM")

        self.section_ids["LEFT"] = self.canvas.create_arc(100, 100, 400, 400, start=135, extent=90,
                                                          outline=self.COLORS["border"],
                                                          fill=self.COLORS["ring"], width=3, tags="LEFT")

        # Add letter indicators to MAIN view (removed number labels 1-4)
        for section, letters in self.letters.items():
            letter_text = ", ".join(letters)
            if section == "TOP":
                self.canvas.create_text(250, 150, text=letter_text, fill=self.COLORS["text"],
                                        font=("Arial", self.FONT["small"]), tags="main_characters")
            elif section == "RIGHT":
                self.canvas.create_text(350, 250, text=letter_text, fill=self.COLORS["text"],
                                        font=("Arial", self.FONT["small"]), tags="main_characters")
            elif section == "BOTTOM":
                self.canvas.create_text(250, 350, text=letter_text, fill=self.COLORS["text"],
                                        font=("Arial", self.FONT["small"]), tags="main_characters")
            elif section == "LEFT":
                self.canvas.create_text(150, 250, text=letter_text, fill=self.COLORS["text"],
                                        font=("Arial", self.FONT["small"]), tags="main_characters")

    def create_circle(self):
        """Draws the central text display circle with a border."""
        self.canvas.create_oval(200, 200, 300, 300, outline=self.COLORS["border"],
                                fill=self.COLORS["background"], width=3, tags="center_circle")
        self.canvas.create_text(250, 250, text=self.current_text, font=("Arial", self.FONT["large"]),
                                fill=self.COLORS["text"], tags="center_text")

    def update_display(self, option: str) -> None:
        """
        Updates the GUI based on the selected mode.
        Modes:
        - 'MAIN'  -> Shows four quadrants (default state).
        - 'RIGHT', 'TOP', 'LEFT', 'BOTTOM' -> Shows secondary panel with characters in a full circle.
        - 'NUM'   -> Displays numeric keypad in a full circle.
        """
        # Clear only the ring and character elements, keep side buttons
        self.canvas.delete("ring")
        self.canvas.delete("characters")
        self.canvas.delete("labels")
        self.canvas.delete("secondary")
        self.canvas.delete("outer_ring")
        self.canvas.delete("main_labels")
        self.canvas.delete("main_characters")

        # Create outer ring FIRST
        self.canvas.create_oval(100, 100, 400, 400, outline=self.COLORS["border"],
                                fill=self.COLORS["background"], width=3, tags="outer_ring")

        # Update display based on current state
        if option == "MAIN":
            # Create the four main sections
            self.section_ids = {}  # Reset section IDs

            # Create TOP section
            counter_top = self.selection_counters["TOP"]
            self.section_ids["TOP"] = self.canvas.create_arc(
                100, 100, 400, 400, start=45, extent=90,
                outline=self.COLORS["border"],
                fill=self.get_color(f"highlight_{counter_top}"),
                width=3, tags=("ring", "TOP")
            )

            # Create RIGHT section
            counter_right = self.selection_counters["RIGHT"]
            self.section_ids["RIGHT"] = self.canvas.create_arc(
                100, 100, 400, 400, start=315, extent=90,
                outline=self.COLORS["border"],
                fill=self.get_color(f"highlight_{counter_right}"),
                width=3, tags=("ring", "RIGHT")
            )

            # Create BOTTOM section
            counter_bottom = self.selection_counters["BOTTOM"]
            self.section_ids["BOTTOM"] = self.canvas.create_arc(
                100, 100, 400, 400, start=225, extent=90,
                outline=self.COLORS["border"],
                fill=self.get_color(f"highlight_{counter_bottom}"),
                width=3, tags=("ring", "BOTTOM")
            )

            # Create LEFT section
            counter_left = self.selection_counters["LEFT"]
            self.section_ids["LEFT"] = self.canvas.create_arc(
                100, 100, 400, 400, start=135, extent=90,
                outline=self.COLORS["border"],
                fill=self.get_color(f"highlight_{counter_left}"),
                width=3, tags=("ring", "LEFT")
            )

            # Add letter indicators to MAIN view (removed number labels 1-4)
            for section, letters in self.letters.items():
                letter_text = ", ".join(letters)
                if section == "TOP":
                    self.canvas.create_text(250, 150, text=letter_text, fill=self.COLORS["text"],
                                            font=("Arial", self.FONT["small"]), tags="main_characters")
                elif section == "RIGHT":
                    self.canvas.create_text(350, 250, text=letter_text, fill=self.COLORS["text"],
                                            font=("Arial", self.FONT["small"]), tags="main_characters")
                elif section == "BOTTOM":
                    self.canvas.create_text(250, 350, text=letter_text, fill=self.COLORS["text"],
                                            font=("Arial", self.FONT["small"]), tags="main_characters")
                elif section == "LEFT":
                    self.canvas.create_text(150, 250, text=letter_text, fill=self.COLORS["text"],
                                            font=("Arial", self.FONT["small"]), tags="main_characters")

        elif option == "NUM":
            # Display numeric characters in circular layout with full 360-degree arcs
            self.secondary_section_ids = {}

            # Create arcs for each number
            for i, num in enumerate(self.numbers):
                start_angle = self.character_positions[(f"{num}_start", "NUM")]
                end_angle = self.character_positions[(f"{num}_end", "NUM")]
                extent = end_angle - start_angle

                # Create arc for this number
                self.secondary_section_ids[num] = self.canvas.create_arc(
                    100, 100, 400, 400, start=start_angle, extent=extent,
                    outline=self.COLORS["border"], fill=self.COLORS["ring"],
                    width=3, tags=("ring", "secondary", f"num_{i}")
                )

                # Add number text - positioned at middle of segment
                x, y = self.character_positions[(num, "NUM")]
                self.canvas.create_text(x, y, text=num, fill=self.COLORS["text"],
                                        font=("Arial", self.FONT["middle"]), tags="characters")

        elif option in ["RIGHT", "TOP", "LEFT", "BOTTOM"]:
            # Show selected section characters in a full circle
            section = option
            chars = self.letters[section]
            self.secondary_section_ids = {}

            # Create arcs for each character
            for i, char in enumerate(chars):
                start_angle = self.character_positions[(f"{char}_start", section)]
                end_angle = self.character_positions[(f"{char}_end", section)]
                extent = end_angle - start_angle

                # Create arc for this character with appropriate highlighting
                counter = self.secondary_counters[section][i]
                fill_color = self.get_color(f"highlight_{counter}")

                self.secondary_section_ids[char] = self.canvas.create_arc(
                    100, 100, 400, 400, start=start_angle, extent=extent,
                    outline=self.COLORS["border"], fill=fill_color,
                    width=3, tags=("ring", "secondary", f"char_{i}")
                )

                # Add ONLY the character text - positioned at middle of segment
                x, y = self.character_positions[(char, section)]
                self.canvas.create_text(x, y, text=char, fill=self.COLORS["text"],
                                        font=("Arial", self.FONT["large"]), tags="characters")

        # ALWAYS draw the center circle and text LAST to ensure it's on top
        self.canvas.delete("center_circle")
        self.canvas.delete("center_text")
        self.canvas.create_oval(200, 200, 300, 300, outline=self.COLORS["border"],
                                fill=self.COLORS["background"], width=3, tags="center_circle")
        self.canvas.create_text(250, 250, text=self.current_text, font=("Arial", self.FONT["large"]),
                                fill=self.COLORS["text"], tags="center_text")

        self.state = option  # Update the state of the interface
        self.active_secondary = None  # Reset active secondary selection
        self.active_secondary_index = -1

    def select_option(self, option: str) -> None:
        """Handles selection of quadrants (LEFT, RIGHT, etc.) and updates state"""
        if option in self.selection_counters:
            # Increment the counter for this section
            self.selection_counters[option] += 1

            # If counter reaches 4, activate secondary panel
            if self.selection_counters[option] >= 4:
                self.selection_counters[option] = 0  # Reset counter
                self.state = option  # Activate secondary panel
                self.update_display(option)
            else:
                # Just update highlighting in MAIN state
                self.update_display("MAIN")
        else:
            self.state = option
            self.update_display(option)

    def select_secondary_option(self, section: str, index: int) -> None:
        """Handles selection of secondary options and updates state"""
        if section in self.secondary_counters and 0 <= index < len(self.secondary_counters[section]):
            # Store the active secondary section and index
            self.active_secondary = section
            self.active_secondary_index = index

            # Increment the counter for this secondary option
            self.secondary_counters[section][index] += 1

            # If counter reaches 4, select this character
            if self.secondary_counters[section][index] >= 4:
                # Add the character to current text
                char = self.letters[section][index]
                self.add_character(char)

                # Reset counter
                self.secondary_counters[section][index] = 0

                # Return to main panel
                self.active_secondary = None
                self.active_secondary_index = -1
            else:
                # Just update the display to show highlighting
                self.update_display(section)
        else:
            print(f"Invalid secondary option: {section}, index {index}")

    def add_character(self, char: str) -> None:
        """Adds the selected letter to current_text"""
        self.current_text += char

        # Reset all selection counters
        for section in self.selection_counters:
            self.selection_counters[section] = 0

        for section in self.secondary_counters:
            for i in range(len(self.secondary_counters[section])):
                self.secondary_counters[section][i] = 0

        # Return to main state
        self.state = "MAIN"
        self.update_display("MAIN")

    def confirm_text(self) -> None:
        """Convert current text to speech and clear"""
        if self.current_text:
            self.tts(self.current_text)
            self.current_text = ""

            # Reset all counters and return to main state
            for section in self.selection_counters:
                self.selection_counters[section] = 0

            for section in self.secondary_counters:
                for i in range(len(self.secondary_counters[section])):
                    self.secondary_counters[section][i] = 0

            self.state = "MAIN"
            self.update_display("MAIN")

    def handle_side_buttons(self, button: str) -> None:
        """
        Handles side button clicks including Confirm, Cancel, Number Toggle, and Return.
        """
        if button == "NUM":
            self.update_display("NUM")
        elif button == "RETURN":
            # Reset all selection counters
            for section in self.selection_counters:
                self.selection_counters[section] = 0

            for section in self.secondary_counters:
                for i in range(len(self.secondary_counters[section])):
                    self.secondary_counters[section][i] = 0

            self.state = "MAIN"  # Reset state to main panel
            self.update_display("MAIN")
        elif button == "CONFIRM":
            self.confirm_text()
        elif button == "DELETE":
            if self.current_text:
                self.current_text = self.current_text[:-1]  # Delete last char
                self.update_display(self.state)

    def command_listener(self):
        """Listen for commands from the terminal"""
        print("\nWelcome to AAC Keyboard - Command Based")
        print("Commands:")
        print("1-4: Select main sections (top=1, right=2, bottom=3, left=4)")
        print("5: Switch to numbers/letters")
        print("6: Return to main panel")
        print("7: Delete last character")
        print("8: Confirm (text-to-speech)")
        print("1a-1g, 2a-2g, etc: Select specific letters in secondary panels")
        print("Type 'exit' to quit\n")

        while True:
            try:
                cmd = input("Enter command: ")

                # Process the command on the main thread
                self.root.after(0, lambda: self.process_command(cmd))

                if cmd.lower() == 'exit':
                    break
            except Exception as e:
                print(f"Error processing command: {e}")

    def process_command(self, cmd: str):
        """Process the received command and update UI accordingly"""
        try:
            if cmd.lower() == 'exit':
                self.root.quit()
                return

            # Check for main section commands (1-4)
            if cmd == '1':
                self.select_option("TOP")
            elif cmd == '2':
                self.select_option("RIGHT")
            elif cmd == '3':
                self.select_option("BOTTOM")
            elif cmd == '4':
                self.select_option("LEFT")

            # Check for corner commands (5-8)
            elif cmd == '5':
                self.handle_side_buttons("NUM")
            elif cmd == '6':
                self.handle_side_buttons("RETURN")
            elif cmd == '7':
                self.handle_side_buttons("DELETE")
            elif cmd == '8':
                self.handle_side_buttons("CONFIRM")

            # Check for secondary selection commands (e.g., 1a, 2b)
            elif re.match(r'^[1-4][a-g]$', cmd):
                section_num = int(cmd[0])
                char_index = ord(cmd[1]) - ord('a')

                # Map section number to section name
                section_map = {1: "TOP", 2: "RIGHT", 3: "BOTTOM", 4: "LEFT"}
                section = section_map.get(section_num)

                if section:
                    if self.state == section:
                        # We're already in the secondary panel, so select this character
                        self.select_secondary_option(section, char_index)
                    elif self.state == "MAIN":
                        # First select the section
                        self.select_option(section)

                        # If selection counter reached 4, we're now in secondary panel
                        if self.state == section:
                            self.select_secondary_option(section, char_index)
            else:
                print("Invalid command. Please use 1-8 or section+letter (e.g., 1a)")
        except Exception as e:
            print(f"Error in process_command: {e}")

    @staticmethod
    def tts(input_text: str) -> None:
        """Converts text to speech using gTTS and plays it with pygame."""
        print(f"Text-to-speech: '{input_text}'")
        file_path = "output.mp3"
        speech = gTTS(input_text, lang='en', tld='co.uk')
        speech.save(file_path)

        # Ensure pygame mixer is initialized before playing
        if not pygame.mixer.get_init():
            pygame.mixer.init()

        pygame.mixer.music.load(file_path)
        pygame.mixer.music.play()

        while pygame.mixer.music.get_busy():
            time.sleep(0.1)

        pygame.mixer.quit()  # Close mixer to release file lock
        try:
            os.remove(file_path)
        except:
            pass  # Ignore if file can't be deleted


def main():
    root = tk.Tk()
    app = AAC_GUI(root)
    root.mainloop()


if __name__ == '__main__':
    main()
